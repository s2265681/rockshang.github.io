(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{467:function(e,t,n){"use strict";n.r(t);var s=n(44),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"vue-code"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue-code"}},[e._v("#")]),e._v(" vue-code")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("1. 源码解析\n2. 项目课\n3. ssr\n4. 自动化测试\n5. 优化\n")])])]),n("ul",[n("li",[n("p",[e._v("知识要点\n工作机制、Vue响应式原理、依赖收集与追踪、编译complie")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191110080306127.png",alt:"vue原理利"}}),e._v("\n◊")])])]),e._v(" "),n("ol",[n("li",[e._v("vue工作机制\n** 初始化**\n在new Vue()之后，Vue会调用进行初始化，会初始化生命周期、props、methods、data\\computed与watch等，其中最重要的是Object.defineProperty设置setter与getter，用来实现响应式与依赖收集")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("初始化之后调用$mount挂在组件\n\nvue原理利用了Object.defineProperty数据劫持,把data里面的每个数据都订阅了set和get方法，当每个数据改变的时候，会知道需要更新的地方。\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("编译compile\n核心逻辑获取dom，遍历dom，获取{{}}格式的变量，以及每个dom的属性，截获k-和@开头的设置响应式\n"),n("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191110091143533.png",alt:"编译compile"}})])]),e._v(" "),n("p",[n("strong",[e._v("vue的编译过程？")]),e._v("\nvue写的模版语句html不识别，\n根据编译过程进行依赖收集，使数据模型和视图之间产生了依赖关系，当模型产生关系的时候，就可以通过这些依赖让他们进行更新，就是执行编译的更新操作，做到模型驱动视图的变化")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("**双向绑定的原理？**\n通过v-model这个指令，在编译的时候解析出v-model，在做操作的时候，1、v-model所属的元素上面添加一个事件监听，把input指定的事件监听函数作为回调监听，数据发生变化set变化，触发更新，就把最新的值设置到vue的实例上，触发页面更新。\n\n思考：\n**如何监听数组push？**\n**自定义组件的实现？**\n\n\n复习：\nnew Vue\n初始化: 数据响应化，对数据劫持， 数据收集-> \n编译: 依赖收集，编译器（把vue特殊的标签编译）， 创建一个watcher，把参数更新函数传给watcher，通过dep管理所有的watcher\n让dep通知当前相关的watcher去做响应的操作，更新update\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);