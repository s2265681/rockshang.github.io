(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{462:function(t,e,a){"use strict";a.r(e);var r=a(44),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"creat-react-app"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#creat-react-app"}},[t._v("#")]),t._v(" creat-react-app")]),t._v(" "),a("p",[t._v("npx create-react-app + 项目名")]),t._v(" "),a("p",[t._v("学写一次到处运行\njsx js 编译成 js 对象\nreact 负责逻辑层控制层\nreact-dom 负责渲染 渲染层")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("组件创建")]),t._v(" "),a("p",[t._v("函数式 rfc\nfunction Comp(props){\nreturn(...)\n}")]),t._v(" "),a("p",[t._v("组件式、类 rcc\nclass Comp extends React.Component{\nrender(){\nreturn(...)\n}\n}")])]),t._v(" "),a("li",[a("p",[t._v("setState 内部激活更新\nthis.setState({}) 异步批量执行，不会立刻拿到结果，改成同步或者通过传入函数获得最新参数\nthis.setState((state)=>{})\nstate 里面是最新的")])]),t._v(" "),a("li",[a("p",[t._v("事件处理")])]),t._v(" "),a("li",[a("p",[t._v("生命周期\nReact V16.3 之前的生命周期")]),t._v(" "),a("p",[t._v("14.4 之后\n新增 fiber")])])]),t._v(" "),a("p",[t._v("![新版的生命周期函数]](https://img-blog.csdnimg.cn/20191009202247333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE2MDM4NQ==,size_16,color_FFFFFF,t_70)")]),t._v(" "),a("p",[t._v("创建时： constructor ->static getDerivedStateFromProps -> shouldComponentUpdate -> render -> getSnapshotBeforeUpdate")]),t._v(" "),a("p",[t._v("componentCatch(error,info){\n错误捕获\n}")]),t._v(" "),a("p",[t._v("复习：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("React 逻辑控制，视图模型的控制 jsx-> React.createElement() 形成虚拟 dom， 维护一组数据，执行 render 函数把数据通过 diff 算法渲染成真正的 dom。")])]),t._v(" "),a("li",[a("p",[t._v("JSX 表达式{expr} 属性 id={expr} jsx 本身也是表达式")])]),t._v(" "),a("li",[a("p",[t._v("组件的描述方式：函数式、组件式")])]),t._v(" "),a("li",[a("p",[t._v("条件和循环\n{三元表达式}\n{短路表达式}\n{.map 循环}")])])]),t._v(" "),a("h2",{attrs:{id:"事件-注意回调函数-this-的指向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件-注意回调函数-this-的指向"}},[t._v("#")]),t._v(" 事件 注意回调函数 this 的指向")]),t._v(" "),a("p",[t._v("< input onChange={this.onChange}>\n1、 < input onChange={()=>this.onChange(参数)}>\n2、 < input onChange={this.onChange.bind(this，\b 参数)}>\n3、 在 constructor 里面绑定 bind")]),t._v(" "),a("h2",{attrs:{id:"通讯"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通讯"}},[t._v("#")]),t._v(" 通讯")]),t._v(" "),a("p",[t._v("< Comp title={} submit={this.submit}>")]),t._v(" "),a("h1",{attrs:{id:"组件化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件化"}},[t._v("#")]),t._v(" 组件化")]),t._v(" "),a("p",[t._v("api 很少，组件化管理，工作方式简单：UI=F(state)")]),t._v(" "),a("p",[t._v("npm install antd --save")]),t._v(" "),a("h2",{attrs:{id:"antd-按需加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#antd-按需加载"}},[t._v("#")]),t._v(" antd 按需加载")]),t._v(" "),a("p",[t._v("安装\n用 react-app-rewired 取代 react-scripts 用来扩展 webpack 配置，类似于 vue 的 vue.config.js\nbabel-plugin-import\n按需加载见 antd 文档")]),t._v(" "),a("h2",{attrs:{id:"组件设计原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件设计原则"}},[t._v("#")]),t._v(" 组件设计原则")]),t._v(" "),a("p",[t._v("容器组件 VS 展示组件\n设计思路：1、工作和展示分离  2、重用性高  3、更高的可用性  4、更易于测试")]),t._v(" "),a("h2",{attrs:{id:"shouldcomponentupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate"}},[t._v("#")]),t._v(" shouldComponentUpdate")]),t._v(" "),a("p",[t._v("CommentList\nshouldComponentUpdate 里面优化\n或者通过 V15 版本之后新增了 PureComponent 纯组件代替 shouldComponentUpdate 优化，内部对 shouldComponentUpdate 做了处理，进行了浅拷贝(注意不能传深层次数据，不要传对象，或者引用地址不发生变化，就可以规避问题，否则会失效)")]),t._v(" "),a("h2",{attrs:{id:"react-memo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-memo"}},[t._v("#")]),t._v(" React.memo")]),t._v(" "),a("p",[t._v("CommentList.js\n** V16.6 之后版本，新增了 React.memo,是高阶组件浅对比（效率高），让函数式组件也有了 PureComponent 的功能,见 CommentList 组件")]),t._v(" "),a("h2",{attrs:{id:"高阶组件-（扩展组件功能，属性）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件-（扩展组件功能，属性）"}},[t._v("#")]),t._v(" 高阶组件 （扩展组件功能，属性）")]),t._v(" "),a("ul",[a("li",[t._v("高阶组件，高阶组件是函数，传入一个组件返回一个新的组件，提高复用率，抽离相同逻辑，在 React 中就有了 HOC（Height-Order Components） 概念，高阶组件是一个函数，但是他返回另一个组件，产生新的组件可以对属性进行包装，也可以重写部分生命周期")])]),t._v(" "),a("h2",{attrs:{id:"高阶组件装饰器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件装饰器"}},[t._v("#")]),t._v(" 高阶组件装饰器")]),t._v(" "),a("p",[t._v("Hoc.js\n高阶组件可以多次链式调用，但是写法蛋疼，于是 ES7 中出了新的写法，装饰器，安装\nnpm install --save-dev babel-plugin-transform-decorators-legacy\n使用装饰器包裹的组件必须要是类，组件式的")]),t._v(" "),a("h2",{attrs:{id:"扩展组件最好不用继承，用复合组件更好更安全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扩展组件最好不用继承，用复合组件更好更安全"}},[t._v("#")]),t._v(" 扩展组件最好不用继承，用复合组件更好更安全")]),t._v(" "),a("p",[t._v("Composition.js\n// 扩展获得函数 Api 值的调用\n// 过略数组\n// 写一个 RedioGroup 组件\n修改和操作 children\nReact.Children")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("   {React.Children.map(props.children,(child)=>{\n       // vdom 不可更改，克隆一个新的去改才行\n       // child.props.name = props.name;\n       // return child;\n       return React.cloneElement(child,{name:props.name})\n   })}\n")])])]),a("p",[t._v("1、函数化组件Hook\n2、上下文Context")]),t._v(" "),a("h2",{attrs:{id:"函数化组件hook（钩子）-最新-v16-8新增项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数化组件hook（钩子）-最新-v16-8新增项"}},[t._v("#")]),t._v(" 函数化组件Hook（钩子）  --\x3e 最新  V16.8新增项")]),t._v(" "),a("p",[t._v("-> HookTest.js")]),t._v(" "),a("p",[t._v("特点：1、不编写class就能享受到class的功能\n2、更简洁 更容易理解\n3、无需更改组件结构，提高复用状态逻辑")]),t._v(" "),a("p",[t._v("升级react 、 react-dom\nnpm i react react-dom -S")]),t._v(" "),a("h2",{attrs:{id:"副作用钩子-effect-hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#副作用钩子-effect-hook"}},[t._v("#")]),t._v(" 副作用钩子 Effect Hook")]),t._v(" "),a("p",[t._v("-> HookTest.js")]),t._v(" "),a("p",[t._v("useEffect就是Effect Hook，给函数增加了副作用的能力，\n跟class中componentidMount，componentDidUpdate，componentWillUnmount")]),t._v(" "),a("p",[t._v("// 副作用钩子会在每次渲染的时候都执行，重新渲染, 第二个是状态依赖，\n是个数组，")]),t._v(" "),a("p",[t._v("写了哪个哪个改变时调用，如[ count ] ,只有count改变时才会调用\n写空[],那么只会执行一次， 任何状态改变都不会调用\n如果不写，哪个状态改变都会执行， 任何状态改变都会调用")]),t._v(" "),a("h2",{attrs:{id:"自定义钩子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义钩子"}},[t._v("#")]),t._v(" 自定义钩子")]),t._v(" "),a("p",[t._v("-> 自定义的Hook是一个函数，名称用use开头，函数内部可以调用其他的钩子")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function useAge(){\n    const [age,setAge] = useState(0);\n    useEffect(()=>{\n        setTimeout(() => {\n            setAge(20);\n      }, 2000);\n    })\n    return age;\n}\n\n")])])]),a("h2",{attrs:{id:"其他hook-usecontext、usereducer、usecallback、usememo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他hook-usecontext、usereducer、usecallback、usememo"}},[t._v("#")]),t._v(" 其他Hook useContext、useReducer、useCallback、useMemo")]),t._v(" "),a("h2",{attrs:{id:"组件跨层级通讯-context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件跨层级通讯-context"}},[t._v("#")]),t._v(" 组件跨层级通讯 - Context")]),t._v(" "),a("p",[t._v("--\x3e ContextType.js")]),t._v(" "),a("ul",[a("li",[t._v("上下文提供一种不需要每层设置props就能跨多级传递数据的方式\nContext的相关api")]),t._v(" "),a("li",[t._v("React.CreateContent")]),t._v(" "),a("li",[t._v("Context.Provider")]),t._v(" "),a("li",[t._v("Class.contextType")]),t._v(" "),a("li",[t._v("Context.Consumer")])]),t._v(" "),a("h2",{attrs:{id:"antdform-js-创建一个表单组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#antdform-js-创建一个表单组件"}},[t._v("#")]),t._v(" AntdForm.js 创建一个表单组件")]),t._v(" "),a("p",[t._v("--\x3e KForm")]),t._v(" "),a("h2",{attrs:{id:"redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" redux")]),t._v(" "),a("p",[t._v("Action->dispatch->store->Reducers(更改状态)->store(数据存储)->state->React Component\n纯粹，单向，同步\nnpm i redux --save")]),t._v(" "),a("p",[t._v("原始redux 繁琐")]),t._v(" "),a("h2",{attrs:{id:"react-redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-redux"}},[t._v("#")]),t._v(" react-redux")]),t._v(" "),a("p",[t._v("npm i react-redux --save")]),t._v(" "),a("h2",{attrs:{id:"react-router"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-router"}},[t._v("#")]),t._v(" react-router")]),t._v(" "),a("h2",{attrs:{id:"异步-react-默认只支持同步，实现异步任务比如延迟，网络请求，需要中间件的支持-如-redux-thunk"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步-react-默认只支持同步，实现异步任务比如延迟，网络请求，需要中间件的支持-如-redux-thunk"}},[t._v("#")]),t._v(" 异步 ->  react 默认只支持同步，实现异步任务比如延迟，网络请求，需要中间件的支持 如 redux-thunk")]),t._v(" "),a("p",[t._v("npm i redux-thunk --save   redux 中间件 dispatch异步操作")]),t._v(" "),a("p",[t._v("npm i redux-logger --save  记录redux 操作日志")]),t._v(" "),a("h2",{attrs:{id:"redux-router-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux-router-4"}},[t._v("#")]),t._v(" redux-router-4")]),t._v(" "),a("p",[t._v("https://www.reacttrainning.com/react-router\nnpm i react-router-dom -S\n-> ReactSample.js\n路由即组件")]),t._v(" "),a("p",[t._v("路由守卫\n具有校验路由功能")]),t._v(" "),a("p",[t._v("-- umi 、 redux解决方案dva 、 generator 、 redux-saga(更强大的异步处理方案和react-thunk(较弱))")]),t._v(" "),a("h2",{attrs:{id:"企业级框架-umi"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#企业级框架-umi"}},[t._v("#")]),t._v(" 企业级框架  -- umi")]),t._v(" "),a("h2",{attrs:{id:"redux-saga"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux-saga"}},[t._v("#")]),t._v(" redux-saga")]),t._v(" "),a("p",[t._v("概述：redux-saga使副作用（数据获取、浏览器缓存获取）易于管理、执行、测试和失败处理\nnpm i --save redux-saga")]),t._v(" "),a("h2",{attrs:{id:"generator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#generator"}},[t._v("#")]),t._v(" generator")]),t._v(" "),a("p",[t._v("function * login(){} * 位置都可以\n生成器函数 他返回一个generator对象 ， 满足可循环可迭代")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" // 定义生成器函数\n function *g(){\n   yield 'a';\n   yield 'b';\n   yield 'c';\n   return 'ending'\n }\n // 返回Generator对象\n  console.log(g()); // g {<suspended>}\n  console.log(g().toString()); // [object Generator]\n\n")])])]),a("h2",{attrs:{id:"企业级开发框架-umi"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#企业级开发框架-umi"}},[t._v("#")]),t._v(" 企业级开发框架 umi")]),t._v(" "),a("ul",[a("li",[t._v("开箱即用 内置 react、react-router")]),t._v(" "),a("li",[t._v("类next.js且功能路由约定，支持路由方式")]),t._v(" "),a("li",[t._v("完善的插件体系")]),t._v(" "),a("li",[t._v("高性能，插件支持PWA")]),t._v(" "),a("li",[t._v("支持静态页面导出，适配各种环境，如 中台业务，无限业务，支付宝钱包，云凤蝶等")]),t._v(" "),a("li",[t._v("一键兼容到IE9，基于umi-pligin-polyfils")]),t._v(" "),a("li",[t._v("完善的TypeScript支持")]),t._v(" "),a("li",[t._v("与dva数据流的深入融合，支持duck directory、model的自动加载、code splitting 等")])]),t._v(" "),a("h2",{attrs:{id:"dva-代替-redux-redux-saga"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dva-代替-redux-redux-saga"}},[t._v("#")]),t._v(" dva 代替 redux redux-saga")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191023143342297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE2MDM4NQ==,size_16,color_FFFFFF,t_70",alt:"dva工作流程"}})]),t._v(" "),a("p",[t._v("原理：(异步) url->Route Component ->dispatch->Action->Effect->Server->Effect->Reducer->State->connect->Route Component")]),t._v(" "),a("p",[t._v("(同步）url->Route Component ->dispatch->Action->Reducer->State->connect->Route Component")]),t._v(" "),a("p",[t._v("订阅一写操作：Subscription---\x3edispatch---Action")]),t._v(" "),a("p",[t._v("约定: src 源码\n1、pages页面\n2、components组件\n3、layout布局\n4、models数据\nconfig 配置\nmock 数据模拟\ntest测试")]),t._v(" "),a("p",[t._v("Umi的基本使用")]),t._v(" "),a("p",[t._v("npm int\nnpm install umi -D    // -D就是–save-dev 开发时的框架，放到devDependencies里面 ， 只有开发时用的")]),t._v(" "),a("p",[t._v("npm install antd -S    // -D就是–save 开发时的框架，放到dependencies 里面 ，运行打包时用的")]),t._v(" "),a("p",[t._v("选型：1、按材选择\n2、Ts vue对Ts还是有点蹩脚，react更容易\n3、Angular 对原生js支持更好")])])}),[],!1,null,null,null);e.default=n.exports}}]);